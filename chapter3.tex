\chapter{Ανάπτυξη του \en{GraKeL}}
\label{chap3}
Η σχεδίαση μίας μοντέρνας βιβλιοθήκης προγραμματισμού δεν είναι μία απλή υπόθεση.
Ο προγραμματιστής καλείται να συνδυάσει ``κοινωνικές'' ιδιότητες της βιβλιοθήκης, όπως η ευχρηστία και η υψηλού επιπέδου οργάνωση, με ιδιότητες ``υλικού'' που προκύπτουν από το στόχο της υπολογιστικής αποτελεσματικότητας.
Σε αυτό το κεφάλαιο θα ασχοληθούμε με την βιβλιοθήκη από την σκοπιά της ανάπτυξης λογισμικού.
Πρώτα θα περιγράψουμε τον βασικό σκελετό οργάνωσης της βιβλιοθήκης, το μοντέλο προγραμματισμού την οργάνωση και το 
Έπειτα θα ασχοληθούμε με συγκεκριμένες υπομονάδες του ίδιου του πακέτου προκειμένου να περιγράψουμε των τρόπο με τον οποίο λειτουργούν καθώς και τις δυνατότητες τους.
Τέλος θα δοθούν συμπληρωματικές πληροφορίες σχετικά με το πως μία σύγχρονη βιβλιοθήκη προγραμματισμού συσκευάζεται \en{packaging}, διανέμεται και δοκιμάζεται.
\section{Σχεδιαστικές Αποφάσεις}
Το \en{GraKeL} επιλέχθηκε να αναπτυχθεί σε γλώσσα προγραμματισμού \en{Python}.
Η γλώσσα αυτή έχει αποδείξει την αξία της τόσο στην έρευνα όσο και στις εφαρμογές \cite{PythonHype}.
Διαθέτει εκτέλεση με διερμηνέα (\en{interpreter}), που διευκολύνει τον προγραμματιστή να αναπτύσσει εφαρμογές πολύ γρήγορα, καθώς λόγω του οκνηρού συστήματος τύπων που διαθέτει, τα σημασιολογικά λάθη προκύπτουν μόνο την στιγμή που θα αποτελέσουν πρόβλημα.
Κάτι τέτοιο κάνει την διαδικασία της διόρθωσης του προγράμματος (\en{debugging}) συγχρονική της ίδια της εκτέλεσης.
Ταυτόχρονα υποστηρίζει το μοντέλο του αντικειμενοστραφούς προγραμματισμού που επιτρέπει την σύγχρονη σχεδίαση μία βιβλιοθήκης.
Στο μοντέλο αυτό η στοιχειώδης δομή δεδομένων καλείται αντικείμενο και αποτελεί πραγματικό στιγμιότυπο στη μνήμη ενός σύνθετου, και πιθανώς οριζόμενου από τον χρήστη, τύπου δεδομένων ονόματι κλάση.
Κάθε κλάση αποτελείται από ιδιότητες εσωτερικές μεταβλητές (\en{attributes}) και μεθόδους.
Π.χ. μία κλάση μπορεί να είναι ο γράφος που διαθέτει ιδιότητες όπως το σύνολο των κόμβων, το σύνολο των ακμών και τις επισημειώσεις και μεθόδους όπως ο υπολογισμός της πυκνότητας του, του πίνακα κοντινότερων μονοπατιών ή ακόμα και πράξεις μεταξύ αντικειμένων αυτής της κλάσης γράφων όπως το γινόμενο.
Το χαρακτηριστικό αυτό μίας γλώσσας δίνει την ευελιξία στην/ον προγραμματίστρια/τιστή τόσο να επεκτείνει τρομερά αποτελεσματικά τις υπάρχουσες δομές δεδομένων που υπάρχουν από την δημιουργία της, όσο και να εκμεταλλεύεται την ανεξάρτητη χρονική οντότητα κάθε αντικειμένου, ενσωματώνοντας το αυτόματα με τις παραμετροποιημένες εκδόσεις ενός σύνολο συναρτήσεων που το αφορούν.
Ακόμα οι συντακτικοί κανόνες της γλώσσας είναι διαμορφωμένοι με τέτοιο τρόπο που η στοίχιση κώδικα χρησιμοποιείται προκειμένου να μειωθεί την χρήση συντακτικών συμβόλων, κάνοντας πολύ ευκολότερη την ανάγνωση του κώδικα και κατ'επέκταση την περαιτέρω ανάπτυξη ή ενσωμάτωση υπάρχοντος κώδικα σε εφαρμογές.

Ο σημαντικότερος βέβαια λόγος για τον οποίο η γλώσσα προγραμματισμού \en{Python} έχει επικρατήσει, που είναι τόσο αποτέλεσμα όσο και η αιτία του σχεδιασμού της είναι το μεγάλο \textit{οικοσύστημα} βιβλιοθηκών, εργαλείων και πλαισίων λογισμικού τα οποία έχουν αναπτυχθεί σε αυτήν τα τελευταία χρόνια ταυτόχρονα με την επικράτηση της ελεύθερης διάθεσης τους κι τροποποίησης τους μέσω των αδειών ανοιχτού λογισμικού.
Για να απλοποιήσουν αυτή τη διαδικασία οι σχεδιαστές της \en{python} δημιούργησαν ένα \en{package manager} γνωστό ως \en{pip} υπεύθυνο για την εγκατάσταση βιβλιοθηκών καθώς και μία πλατφόρμα γνωστή ως \en{PyPi} στην οποία οποιοσδήποτε μπορεί να ανεβάσει πακέτα προς εγκατάσταση.
Πολύ σημαντικός παράγοντας στην διάδοση, τον διαμοιρασμό και την επεξεργασία του ανοιχτού κώδικα αποτέλεσε η ύπαρξη ηλεκτρονικών αποθετηρίων (\en{repositories}) όπως το \en{GitHub}.
Χρησιμοποιώντας ένα λογισμικό που είχε αρχικά αναπτυχθεί για τον συνεπή έλεγχο των εκδόσεων (\en{version control}) στην ανάπτυξη του πυρήνα του \en{Linux}, γνωστό ως \en{git}, ηλεκτρονικά αποθετήρια αυτής της μορφής καθιστούν ιδιαίτερα εύκολη την προβολή, χρήση και την συνεισφορά ή επέκταση του κώδικα οποιουδήποτε χρήστη τους από οποιονδήποτε άλλο.
\subsection{Το πρότυπο του \en{scikit-learn}}
Μία πολύ γνωστή βιβλιοθήκη μηχανικής μάθησης στην \en{Python} είναι γνωστή ως \en{scikit-learn}. Εκτός από τις πολύ γρήγορες υλοποιήσεις ενός μεγάλου πλήθους αλγορίθμων σε ένα μεγάλο εύρος τεχνικών στο χώρο της μηχανικής μάθησης η βιβλιοθήκη αυτή συνδυάζει τρομερή ευχρηστία ταυτόχρονα με αναλυτικά εγχειρίδια για όλους τους διαφορετικούς υποψήφιους χρήστες της (οι οποίοι είναι της τάξης των εκατομμυρίων) \cite{scikit}.
Προκειμένου διάφοροι χρήστες της να μπορούν να προτείνουν δυνατές επεκτάσεις της καθώς και για να καθιερώσει ένα πρότυπο κλάσεων μηχανικής μάθησης για τον αντικειμενοστραφή προγραμματισμό, ένα πλαίσιο λογισμικού \en{sklearn-template} δημιουργήθηκε στο \en{GitHub}.
Λόγω των παραπάνω και με βάση το γεγονός ότι δεν υπήρχε υποστήριξη για το είδος των τεχνικών πυρήνα, συγκεκριμένα των πυρήνων γράφων το παραπάνω σχεδιαστικό πρότυπο επιλέχθηκε για την ανάπτυξη του \en{GraKeL}.
Σαν σχέση υιοθέτησης δύο θεμελιωδών κλάσεων του scikit-learn συγκεκριμένα της κλάσης \en{\texttt{sklearn.base.\textbf{BaseEstimator}}} και της κλάσης \en{\texttt{sklearn.base.\textbf{TransformerMixin}}} σχεδιάστηκε η βασική κλάση του \en{grakel}, γνωστή ως \en{\texttt{grakel.\textbf{Kernel}}}.
Κάθε υλοποίηση ενός πυρήνα γράφων να αποτελεί μία κλάση που υιοθετεί την κλάση \en{\texttt{Kernel}}. 
Η κλάση αυτή αποτελεί κάτι ενδιάμεσο μίας διεπαφής (δηλ. ενός συνόλου δηλώσεων ονομάτων μεθόδων και χαρακτηριστικών με κενό περιεχόμενο) και μία κανονικής κλάσης.
Συγκεκριμένα περιέχει κατάλληλες μεθόδους που αν υλοποιηθούν από τον προγραμματιστή η ανάπτυξη του πυρήνα συντομεύεται.
Ταυτόχρονα κάθε αντικείμενο που είναι ένας έγκυρος πυρήνας μεταξύ γράφων πρέπει να υλοποιεί κάποιες βασικές μεθόδους και συνεπώς να υλοποιεί μία διεπαφή.
Όλοι οι πυρήνες τοποθετήθηκαν σε ένα υπο-πακέτο του \en{grakel} υπό την διεύθυνση \en{\texttt{grakel.kernels}}.
Κάθε αντικείμενο που υλοποιεί το πρότυπο \en{\texttt{TransformerMixin}} υλοποιεί τρεις μεθόδους:
  \begin{itemize}
    \item \texttt{\en{fit}}: Προσαρμογή του μοντέλου σε ένα σύνολο δεδομένων γνωστό ως \textit{σύνολο εκπαίδευσης} (εξαγωγή χαρακτηριστικών, παραμετροποίηση κ.α.)
    \item \texttt{\en{transform}}: Υπολογισμός των τιμών του μοντέλου σε ένα \textit{πειραματικό σύνολο}, βάση του αποτελέσματος της παραμετροποίησης στο σύνολο εκπαίδευσης
    \item \texttt{\en{fit\_transform}}: Προσαρμογή και υπολογισμός του μοντέλου στο \textit{σύνολο εκπαίδευσης} (κάποιες φορές μπορεί να προσφέρει μία γρηγορότερη υλοποίηση από την ακολουθία \texttt{\en{fit}} - \texttt{\en{transform}} στα ίδια δεδομένα)
\end{itemize}
Ταυτόχρονα το πρότυπο \en{\texttt{BaseEstimator}} αποτελείται από δύο μεθόδους \texttt{\en{set\_params}}, \texttt{\en{get\_params}}, οι οποίες αν υλοποιηθούν σωστά καθιστούν δυνατή την εξαγωγή παραμέτρων αρχικοποίησης \en{initialization parameters} καθώς και την εξωτερική επανάθεση αυτών των παραμέτρων σε ένα αρχικοποιημένο αντικείμενο μιας κλάσης προκειμένου να ξαναχρησιμοποιηθεί αρχικοποιημένο με διαφορετικές παραμετροποιήσεις, χωρίς την χρήση της ίδιας της κλάσης.
Κάθε κλάση πρέπει περαιτέρω να διατυπώνει όλες τις παραμέτρους ορισμού της, ρητά.
Τα παραπάνω είναι σημαντικά προκειμένου ένας \en{Transformer} που σχεδιάζει ο προγραμματιστής να μπορεί να εισαχθεί στο λεγόμενο \en{scikit-learn \texttt{Pipeline}}.
Ως τέτοιο μπορεί να εισαχθεί, να αντικατασταθεί και να προσαρμοστεί εύκολα και αφηρημένα σε μία δομή υψηλού επιπέδου βημάτων επεξεργασίας - ταξινόμησης - αξιολόγησης μίας αρχικής εισόδου δεδομένων, σχεδιάζοντας σχεδόν σε διανοητικό επίπεδο μία εφαρμογή ή ένα πείραμα μηχανικής μάθησης.
Για να τηρούνται συνεπώς τα παραπάνω σημαντική ήταν η σχεδίαση της κλάσης πυρήνα.
\subsection{Σχεδίαση της κλάσης \texttt{\en{Kernel}}}
Όπως είδαμε στο κεφάλαιο \ref{chap2}, ένας πυρήνας μεταξύ γράφων εμφανίζεται συνήθως στη βιβλιογραφία σαν μία συνάρτηση: $k \; : \; \mathcal{G} \times \mathcal{G} \rightarrow \mathbb{R}$ για την οποία υπάρχει μία απεικόνηση:$$\phi \; :\; \mathcal{G} \rightarrow \mathbb{H}, \text{για έναν χώρο \en{Hilbert} } \mathbb{H}$$ όπου κάθε τιμή πυρήνα μπορεί να υπολογιστεί ως $k(G_{i}, G_{j}) = \langle G_{i}, G_{j} \rangle$ όπου $\langle \;.\; ,\; .\;\rangle$ αναπαριστά ένα εσωτερικό γινόμενο σε αυτόν τον χώρο. Η μήτρα $[\mathcal{K}]_{ij} = k(G_{i}, G_{j})$ που προκύπτει από όλα τα ζευγάρια γράφων μίας συλλογής, ονομάζεται μήτρα πυρήνα (βλ. \ref{def:kernel_matrix}). Οποιαδήποτε μήτρα που προκύπτει από ένα μέτρο ομοιότητας είναι μήτρα πυρήνα αν για κάθε συλλογή εισόδων είναι θετικά ημιορισμένη (βλ. \ref{def:psd_km}), δηλαδή αν $\forall \mathcal{K}\; \lambda_{min}(\mathcal{K}) \ge 0$, όπου $\lambda_{min}(\mathcal{K})$ η μικρότερη ιδιοτιμή του πίνακα $K$.
%Note
%The ones implemented inside this package all have a \textbf{Polynomial} time complexity.
Μελετώντας υπάρχουσες υλοποιήσεις πυρήνων στη βιβλιογραφία αυτό που διαπιστώσαμε ήταν ότι αν αντί να σχεδιάζαμε την κλάση πυρήνα ώστε να υπολογίζεται μεταξύ ζευγαριών, την σχεδιάζαμε για μία συλλογή γράφων $[G]_{i=1}^{N}$ θα είχαμε σημαντικά υπολογιστικά πλεονεκτήματα.

Ο τρόπος με τον οποίο η κλάση \en{\texttt{Kernel}} σχεδιάστηκε πάνω στο πρότυπο του \en{\texttt{Transformer}} είναι ο ακόλουθος:
\begin{itemize}
    \item \texttt{\en{fit}}: Εξαγωγή χαρακτηριστικών για ένα σύνολο γράφων εκπαίδευσης
    \item \texttt{\en{transform}}: Υπολογισμός του πίνακα πυρήνα μεταξύ ενός συνόλου γράφων πειραματισμού και των αρχικών, είτε εξάγοντας και συγκρίνοντας όμοια χαρακτηριστικά με αυτά του \texttt{\en{fit}} είτε υπολογίζοντας τιμές βάση των χαρακτηριστικών του \texttt{\en{fit}} είτε τέλος επεκτείνοντας τα και υπολογίζοντας μία γενικής μετρικής (χωρίς βέβαια την αποθήκευση της επέκτασης).
\end{itemize}
Τέλος για \texttt{\en{fit\_transform}} έχουμε ένα συνδυασμό των παραπάνω πράγμα που συνήθως αποτελεί την μόνη λειτουργία εκτελούν όλοι οι υπάρχοντες υλοποιημένοι πυρήνες της βιβλιογραφίας από τους ίδιους τους σχεδιαστές τους.

Για να γίνει πιο σαφές το παραπάνω με βάση την μήτρα πυρήνα, δεδομένου δύο συλλογών γράφων (εκπαίδευσης/πειράματος): $G^{n}, G^{m}$, θεωρούμε την πλήρη μήτρα πυρήνα $\mathcal{K}$ ως:
\begin{equation}
\mathcal{K} =
\left[
\begin{array}{c||c}
\mathcal{K}^{n\times n} & \mathcal{K}^{n\times m} \\
\hline
\hline
\mathcal{K}^{m\times n} & \mathcal{K}^{m\times m}
\end{array}
\right]
\label{eq:kernel_matrix}
\end{equation}

Τότε κάθε πυρήνας κλάση που υλοποιεί την κλάση \en{\texttt{Kernel}}, θα πρέπει να έχει την ακόλουθη συμπεριφορά:
\begin{itemize}
\item $\mathcal{K}^{n\times n}=\texttt{\en{<KernelName>.fit\_transform}}(\mathcal{G}^{n})$
\item $\mathcal{K}^{m\times n}=\texttt{\en{<KernelName>.fit}}(\mathcal{G}^{\text{n}}).\texttt{transform}(\mathcal{G}^{\text{m}})$
\item $\mathcal{K}=\texttt{\en{<KernelName>.fit\_transform}}([\mathcal{G}^{n}\; \mathcal{G}^{m}])$
\end{itemize}
Σε ένα πρόβλημα ταξινόμησης γράφων (βλ. \ref{subsection:graph_classification}), αυτό που χρειάζεται να υπολογίσουμε είναι οι πυρήνες $\mathcal{K}^{n\times n}$ και $\mathcal{K}^{m\times n}$. Μία τέτοια συμπεριφορά προέκυψε και ως αναγκαιότητα για την ένταξη κάθε \texttt{\en{Kernel}} στο \en{\texttt{Pipeline}}.

Εν συνεχεία κάθε πυρήνας σχεδιάστηκε με την ακόλουθη στοιχειώδη \textit{παραμετροποίηση}:
\begin{itemize}
\item \en{\texttt{verbose}} Μία λογική (\en{\texttt{bool}}) παράμετρος για να δίνει την δυνατότητα στον προγραμματιστή να παρέχει πληροφορία σχετικά με την πορεία εκτέλεση του kernel σε περίπτωση επιθυμίας του χρήστη.
\item \en{\texttt{normalize}} Η κανονικοποίηση είναι μία πολύ σημαντική ιδιότητα που πρέπει να ακολουθεί ένας πυρήνας προκειμένου να είναι χρήσιμος σε πειράματα ταξινόμησης. Αυτή η λογική (\en{\texttt{bool}}) παράμετρος αναγκάζει τον προγραμματιστή να μπορεί να εξασφαλίζει στον χρήστη της βιβλιοθήκης ότι σε περίπτωση που το επιθυμεί η ο πίνακας πυρήνας θα είναι κανονικοποιημένος τόσο στα αποτελέσματα του \en{\texttt{fit\_transform}} όσο και του \en{\texttt{transform}} Η κανονικοποίηση είναι μία πολύ απλή πράξη διαίρεσης δεδομένων των τιμών της διαγωνίου της μήτρας πυρήνα ως εξής:
    \begin{equation}
        [\mathcal{\hat{K}}]_{ij} = \frac{[\mathcal{K}]_{ij}}{\sqrt[]{[\mathcal{K}]_{ii}*[\mathcal{K}]_{jj}}}
    \end{equation}
\item \en{\texttt{n\_jobs}} Μία ακέραια \en{\texttt{int}} παράμετρος που προσδιορίζει το πλήθος των παράλληλων εργασιών στις οποίες επιθυμεί ο χρήστης να διαμοιραστούν οι παραλληλοποιήσιμες εργασίες του συγκεκριμένου πυρήνα, αν υπάρχουν.
\end{itemize}

Όσον αφορά την υλοποίηση των λίγων ως τώρα \en{framework} δεν ορίστηκε μία ξεχωριστή κλάση.
Παρόλαυτα η σχεδίαση τους είχε ως κοινό χαρακτηριστικό την προσθήκη μίας παραμέτρου αρχικοποίησης (στο όνομα \en{\texttt{base\_kernel}}) η οποία μπορούσε να είναι είτε μία κλάση τύπου \en{\texttt{Kernel}} είτε μία τούπλα (\en{\texttt{tuple}}) δύο στοιχείων με πρώτο μία κλάση τύπου \en{\texttt{Kernel}} και δεύτερο ένα σύνολο ορισμάτων.
Για να είναι δυνατή η κανονικοποίηση του αποτελέσματος των \en{framework} μία νέα μέθοδος χρειάστηκε να προστεθεί σχεδιαστικά σε κάθε αντικείμενο της κλάσης \en{\texttt{Kernel}}: η μέθοδος \en{\texttt{diagonal}}.
Η μέθοδος δεν δέχεται ορίσματα και πρέπει να έχει πάντοτε την ακόλουθη συμπεριφορά. Αν ένας πυρήνας έχει γίνει \en{\texttt{fit}} αλλά όχι \en{\texttt{transform}}, τότε επιστρέφει την διαγώνιο $[\mathcal{K}^{n\times n}]_{ii}$ (πρβλ. \ref{eq:kernel_matrix}).
Αν αντίθετα ένας πυρήνας έχει γίνει \en{\texttt{fit}} και \en{\texttt{transform}} τότε επιστρέφει την διαγώνιο του $[\mathcal{K}^{n\times n}]_{ii}$ και την διαγώνιο του $[\mathcal{K}^{m\times m}]_{jj}$ από το τελευταίο \en{\texttt{transform}}.
Σημαντικό εδώ είναι να σημειώσουμε ότι τα στοιχεία της διαγωνίου $[\mathcal{K}^{m\times m}]_{jj}$ δεν υπολογίζονται κατά το \en{\texttt{transform}} (δλδ. οι τιμές πυρήνα όλων των στοιχείων με τον εαυτό τους), αν ο χρήστης δεν έχει επιλέξει κανονικοποίηση.

Με σκοπό την ύπαρξη μίας κύριας κλάσης - αφηρημένης διεπαφής στην οποία ο χρήστης να απευθύνεται προκειμένου να αρχικοποιήσει έναν πυρήνα, να δημιουργήσει εύκολα ιεραρχίες \en{\texttt{framework/base-kernel}} και να μπορεί να εκτελεί γενικότερες πρόσθετες εξωτερικές λειτουργίες που χρησιμοποιούν τον πίνακα πυρήνα (π.χ. να υπολογίσει προσεγγίσεις του, όπως η προσέγγιση \en{Nystr{\"o}m}), ένα αντικείμενο σχεδιάστηκε στο σχεδιαστικό πρότυπο του \en{decorator} ονόματι \texttt{\en{GraphKernel}}.

\subsection{Γενική Μορφή Εισόδου}
Η ανάγκη σχεδιαστικής ενοποίησης όλων των πυρήνων οδήγησε και στην ανάγκη δημιουργία ενός προτύπου αναπαράστασης της εισόδου των μεθόδους \en{\texttt{fit}, \texttt{fit\_transform }} και \en{\texttt{transform}} καθενός αντικειμένου τύπου \en{\texttt{Kernel}}.
Ακολουθώντας το πρότυπο του \en{scikit-learn} για άλλους \en{\texttt{Transformer}} όπως ο \en{tf-idf}, η είσοδος θεωρήθηκε σαν ένας \textit{\en{graph vectorizer}} ή αλλιώς ένα \en{\texttt{Iterable}} από γράφους (πρβλ. \ref{fig:graph}).
Κάθε γράφος μπορεί να αναπαρασταθεί από ένα \en{\texttt{Iterable}} τουλάχιστον ενός και το πολύ τριών στοιχείων.

Πρώτο στοιχείο κάθε γράφου πρέπει να είναι ένα αντικείμενο που αναπαριστά το γράφο ως δομή.
Οι υπάρχουσες αναπαραστάσεις γράφων στην βιβλιογραφία χωρίζονται σε αυτές που βασίζονται στις ακμές του γράφου ($1$) και σε αυτές που βασίζονται στους κόμβους ($2$).
Οι πρώτες αναπαραστάσεις μπορούν να είναι από μία λίστα κόμβων μέχρι ένα λεξικό, ενώ οι δεύτερες περιγράφονται κυρίως με έναν πίνακα γειτνίασης.
Ως δεύτερο στοιχείο μπορούμε να έχουμε ένα λεξικό που αναπαριστά τις επισημειώσεις των κόμβων του γράφου. Οι επισημειώσεις μπορούν να είναι είτε βαθμωτές, σύμβολα είτε διανύσματα πραγματικών τιμών (χαρακτηριστικά, πρβλ \ref{def:labeled_graphs}).
Τρίτο και τελευταία στοιχείο είναι ένα λεξικό μεταξύ ζευγαριών κόμβων για όλες τις υπάρχουσες ακμές και είτε βαθμωτών, συμβολικών επισημειώσεων είτε διανυσμάτων πραγματικών τιμών.
Τα δύο στοιχεία μπορούν να παραληφθούν ή να αντικατασταθούν από κενά ορίσματα (τύπου \en{\texttt{None}}) στην περίπτωση που δεν υπάρχουν.

Η αναπαράσταση των γράφων ήταν πολύ σημαντική για τους ίδιους τους πυρήνες.
Πολλοί πυρήνες όπως ο \textit{πυρήνας τυχαίων περιπάτων} χρησιμοποιούν άμεσα τον πίνακα γειτνίασης, πυρήνες όπως ο \textit{πυρήνας κοντινότερων μονοπατιών} χρειάζονται μόνο τον πίνακα κοντινότερων μονοπατιών (που υπολογίζεται ταχύτερα αν έχουμε αναπαράσταση ακμών, λόγω του αλγορίθμου Dijkstra) ενώ άλλοι πυρήνες όπως για παράδειγμα ο \en{ODD-STh} χρησιμοποιούν δευτερεύουσα πληροφορία του γράφου που αν κωδικοποιηθεί σωστά εξάγεται γρηγορότερα σε μία από τις δύο αναπαραστάσεις.
Συνεπώς χρειάζονταν ένας τρόπος προκειμένου οι γράφοι να μην αναπαριστούν πολύ μνήμη, ενώ ταυτόχρονα να μπορούμε να ελέγχουμε το είδος της εσωτερικής εσωτερική αναπαράστασης ανά περίπτωση, έχοντας ταυτόχρονα την δυναότητα να καθορίσουμε την μορφή του αποτελέσματος συναρτήσεων πάνω στους γράφους, χρήσιμων για τους υπολογισμούς των πυρήνων, χωρίς να χρειάζεται συνεχώς να ασχολούμαστε με την μορφή της πρώτης.
Ως αποτέλεσμα δημιουργήθηκε η κλάση \en{\texttt{grakel.Graph}} η οποία ενοποίησε την είσοδο του χρήστη σε δύο βασικές εσωτερικές αναπαραστάσεις των οποίων την ύπαρξη ή συνύπαρξη καθορίζει ο προγραμματιστής των πυρήνων και από τις οποίες μπορεί να εξάγει χρήσιμη πληροφορία για τους πυρήνες χωρίς να ασχολείται μετέπειτα κατά τον προγραμματισμού του με την μορφή των δεδομένων εισόδου ή της ίδια της εσωτερικής αναπαράστασης.
Παρόλο που μία τέτοια σχεδιαστική προσέγγιση φαίνεται πολύ απλοϊκή προτιμήθηκε σε σχέση με την χρήση μίας υπάρχουσας βιβλιοθήκης όπως η \en{\texttt{networkx}}, μίας και χρειάζεται για την επίλυση ενός στενά καθορισμένου προβλήματος με το λιγότερο δυνατό κόστος.

\begin{figure}[]
    \centering
    \includegraphics[width=\textwidth]{figures/Graph}
    \caption{Σχηματική απεικόνιση του τρόπου αναπαράστασης της εισόδου για της μεθόδους \texttt{\en{fit}}, \texttt{\en{fit\_transform}} και \texttt{\en{transform}} κάθε αντικειμένου τύπου \en{\texttt{Kernel}}}
    \label{fig:graph}
\end{figure}
% datasets

Σημαντικό κομμάτι της ίδιας της ανάπτυξης του λογισμικού είναι η δυνατότητα εκτέλεσης \en{benchmarks}.
Για το λόγο αυτό υπήρχε η ανάγκη παροχής υπηρεσιών εύκολης εισαγωγής γνωστών \en{dataset} που χρησιμοποιούνται στο χώρο των πυρήνων γράφων.
Για να καλύψουμε αυτήν την ανάγκη οδηγηθήκαμε στην ανάπτυξη μίας συνάρτησης εν'ονόματι \en{\texttt{fetch\_dataset}} σε ένα υποπακέτο του \en{\texttt{grakel}} με το όνομα \en{\texttt{datasets}}.
Η συνάρτηση αυτή είναι υπεύθυνη για το κατέβασμα (\en{downloading}), την φόρτωση (\en{loading}) και την τοπική απόθεση (\en{caching}) ενός \en{dataset} από μία τεράστεια συλλογή όπως αυτή συντηρείται και ελέγχεται από την ερευνητική ομάδα για τους πυρήνες γράφων στο πανεπιστήμιο του \en{Dortmund} \cite{KKMMN2016}. Κάθε \en{dataset} αποθηκεύεται σε μία τοπική διεύθυνση, ώστε να μπορεί να χρησιμοποιηθεί στο μέλλον χωρίς την ύπαρξη σύνδεσης στο διαδίκτυο.

H συνολική οργάνωση του \en{grakel} όπως αναφέρθηκε, συνοψίζεται παρακάτω:
\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{figures/grakel-schema}
    \caption{Σχηματική απεικόνιση της οργάνωσης του λογισμικού \en{grakel}. Οι ρόμβοι αναπαριστούν υποπακέτα (\en{submodules}) ενώ τα παραλληλόγραμμα κλάσεις.}
    \label{fig:grakel}
\end{figure}
\section{Ανάπτυξη ενός πυρήνα: Η κλάση \en{\texttt{Kernel}}}
Ας δούμε τώρα πιο αναλυτικά την σχεδίαση της κλάσης \en{\texttt{Kernel}} που αποτελεί την κύρια και σημαντικότερη οντότητα αυτής της βιβλιοθήκης (πρβλ. \ref{fig:kernel_structure}).
Από την μελέτη της σχετικής βιβλιογραφίας ο υπολογισμός ενός γράφου πυρήνα μπόρεσε να αποδομηθεί στα εξής δύο αφηρημένα βήματα: ανάγνωση της εισόδου και εξαγωγή χαρακτηρηστικών ($1$) και υπολογισμός πίνακα πυρήνα ($2$).
\subsection{Η μέθοδος \texttt{\en{fit}}}
Κατά την κλήση της μεθόδου \texttt{\en{fit}} η βασική συνάρτηση η οποία καλείται είναι η \texttt{\en{parse\_input}} σχεδιασμένη για να φέρει εις πέρας το ($1$) και να αποθηκεύσει τα χαρακτηριστικά σε μία ιδιότητα της κλάσης.
Παράλληλα προκειμένου η κλάση \en{\texttt{Kernel}} να υιοθετεί σωστά τον \en{\texttt{BaseEstimator}} ήταν αναγκαίο η μέθοδος \en{\texttt{set\_params}} να δουλεύει αποτελεσματικά έπειτα από την αρχικοποίηση ενός αντικειμένου, ενώ ταυτόχρονα στην μέθοδο  \en{\texttt{\_\_init\_\_}} όλες οι παράμετροι εισόδου έπρεπε να αρχικοποιούν ιδιότητες με το ίδιο όνομα, για να δουλεύει η μέθοδος \en{\texttt{get\_params}}.
Ο έλεγχος μεταβλητών και η αρχικοποίηση δευτερεύοντων χαρακτηριστικών ανατέθηκε στην συνάρτηση \texttt{\en{initialize\_}} η οποία καλείται στην πρώτη γραμμή της συνάρτησης μεθόδου \texttt{\en{fit}}.

\subsection{Η μέθοδος \texttt{\en{fit\_transform}}}
Για τον υπολογισμό της μήτρας πυρήνα είναι υπεύθυνες δύο μέθοδοι:\\ η \texttt{\en{\_calculate\_kernel\_matrix}} ($1$) και  η \texttt{\en{pairwise\_operation}} ($2$).
Στην περίπτωση του \texttt{\en{fit\_transform}} η πρώτη μέθοδος καλείται στο σύνολο των δεδομένων που έχουν αποθηκευθεί μετά την κλήση της μεθόδου \texttt{\en{parse\_input}} σε μία εσωτερική ιδιότητα της κλάσης \texttt{\en{self.X}}.
Τα δεδομένα αναμένονται να είναι στην μορφή ενός \texttt{\en{Iterable}} το οποίο σε κάθε στοιχείο περιέχει τα εξαχθέντα χαρακτηριστικά που αφορούν τον κάθε πυρήνα.
Χρησιμοποιώντας αυτά τα χαρακτηριστικά υπολογίζουμε την μήτρα πυρήνα, εφαρμόζοντας την μέθοδο \texttt{\en{pairwise\_operation}} μεταξύ κάθε ζευγαριού της άνω διαγώνιου (καθώς η μήτρα πυρήνα είναι πάντα συμμετρική).
Συνεπώς ο υπολογισμός της μήτρας πυρήνα κατανέμεται μεταξύ του υπολογισμού χαρακτηριστικών και της εφαρμογής μίας μετρικής μεταξύ τους.
Στις ακραίες περιπτώσεις (όπως συμβαίνει π.χ. με τα \en{\textit{R-frameworks}}) τα χαρακτηριστικά είναι τέτοια που ο υπολογισμός της μήτρας πυρήνα μπορεί να είναι ισοδύναμος με ένα γινόμενο πινάκων.
Όταν συμβαίνει κάτι τέτοιο, κατά την ανάπτυξη του πυρήνα είναι προτιμότερο να παραληφθεί η μέθοδος \texttt{\en{pairwise\_operation}} και να επανεγραφεί η μέθοδος \texttt{\en{\_calculate\_kernel\_matrix}}.
Όσον αφορά την μέση περίπτωση που το υπολογιστικό κόστος κατανέμεται μεταξύ του συνήθως σειριακού \texttt{\en{parse\_input}} και του \texttt{\en{pairwise\_operation}} μία θεμελιώδης μέθοδος παραλληλοποίησης υλοποιήθηκε για τον υπολογισμό του πίνακα πυρήνα.
Συγκεκριμένα δεδομένου του πλήθους των στοιχείων της άνω διαγωνίου ίσο με $\frac{N(N+1)}{2}$ και ενός πλήθος παράλληλων εργασιών \texttt{\en{n\_jobs}} χωρίζουμε ομοιόμορφα τη λίστα δεικτών $K = [0, \dots, \frac{N(N+1)}{2}-1]$, μπορούμε έπειτα να πάρουμε τους δείκτες του ζητούμενου ζευγαριού γράφων $(i,j)$ που αντιστοιχούν σε ένα $k \in K$ ως:
\begin{align}
    i &= \left\lfloor N - 1 - \left\lfloor \frac{\sqrt{4N(N+1) - 8k - 7} - 1}{2}\right\rfloor \right\rfloor\\
    j &= \left\lfloor k + i - \left\lfloor \frac{N(N+1)}{2} \right\rfloor + \left\lfloor \frac{(N-i)(N-i+1)}{2} \right\rfloor \right\rfloor
\end{align}
Η υπολογιστική ωφελιμότητα της παραλληλοποίησης εξαρτάται από το υπολογιστικό κόστος της μεθόδου \texttt{\en{pairwise\_operation}}, πράγμα που μας απαγορεύει να την εγγυηθούμε στην γενική περίπτωση.

Στην περίπτωση που ο χρήστης επιθυμεί μία κανονικοποιημένη μήτρα πυρήνα η μέθοδος \texttt{\en{fit\_transform}} διαιρεί στοιχείο προς στοιχείο τις τιμές του πίνακα με την τετραγωνική ρίζα κάθε στοιχείου του εξωτερικού γινομένου της διαγωνίου με τον εαυτό της.
Η διαγώνιος του πίνακα πυρήνα αποθηκεύεται σε κάθε περίπτωση σε μία εσωτερική μεταβλητή προκειμένου να μπορεί να χρησιμοποιηθεί χωρίς να επανυπολογιστεί κατά την κλήση της μεθόδου \texttt{\en{diagonal}}.
\subsection{Η μέθοδος \texttt{\en{transform}}}
Όσον αφορά τώρα την περίπτωση του \texttt{\en{transform}} όλες οι μέθοδοι που αναφέρθηκαν παραπάνω θα πρέπει να προσαρμοστούν.
Συγκεκριμένα το \texttt{\en{parse\_input}} καλείται να σχηματίσει χαρακτηριστικά συγκρίσιμα με τα δεδομένα του \texttt{\en{fit}}.

\begin{figure}[]
    \centering
    \includegraphics[width=0.6\textwidth]{figures/KernelStructure.png}
    \caption{Σχηματική απεικόνιση του τρόπου οργάνωσης των μεθόδων της κλάσης \en{\texttt{Kernel}}. Τα νούμερα συμβολίζουν την κλήσης άλλων μεθόδων από την εκάστοτε μέθοδο. Η διακοπτόμενη κλήση αφορά την περίπτωση που κατά την αρχικοποίηση η παράμετρος normalization είναι \en{\texttt{True}}.}
    \label{fig:kernel_structure}
\end{figure}

Σε πολλές περιπτώσεις κάτι τέτοιο απαιτεί την αποθήκευση μετα-πληροφορίας κατά το \texttt{\en{fit}} (π.χ. ενός λεξικού που λειτουργεί ως αρίθμηση των επισημειώσεων) αλλά και της δυνατότητας του \texttt{\en{parse\_input}} να γνωρίζει αν καλείται από το \texttt{\en{transform}}, το \texttt{\en{fit}} ή και σε κάποιες περιπτώσεις από το \texttt{\en{fit\_transform}}.
Κάτι τέτοιο φυσικά επιλύεται με την χρήση μία ιδιωτικής \texttt{\en{self.\_method\_calling}} ιδιότητας της κλάσης, που είναι $1, 2, 3$ κατά τα \texttt{\en{fit}}, \texttt{\en{fit\_transform}} και \texttt{\en{transform}} αντίστοιχα.
Εν συνεχεία κατά την κλήση της συνάρτησης \texttt{\en{\_calculate\_kernel\_matrix}} μεταξύ όλων των ζευγαριών των δεδομένων του \texttt{\en{transform}} και του \texttt{\en{fit}}, υπολογίζουμε \texttt{\en{pairwise\_operation}}.
Σε αυτήν την περίπτωση, δεδομένου ενός πλήθος παράλληλων εργασιών \texttt{\en{n\_jobs}} η παραλληλοποίηση επιτυγχάνεται αν χωρίζουμε ομοιόμορφα την λίστα δεικτών $K = [0, \dots, Ν Μ - 1]$ (όπου $Μ$ το πλήθος των δεδομένων κατά το \texttt{\en{transform}}), και έπειτα για κάθε $k \in K$ εξάγουμε για κάθε επεξεργαστή τα ζευγάρια δεικτών $(i,j)$ ως $(k\mod N, \lfloor \frac{k}{N} \rfloor)$.

Στην περίπτωση που ο χρήστης επιθυμεί μία κανονικοποιημένη μήτρα πυρήνα η μέθοδος \texttt{\en{transform}} καλεί την μέθοδο \texttt{\en{diagonal}} η οποία επιστρέφει το διάνυσμα της τιμής πυρήνα όλων των στοιχείων του \texttt{\en{fit}} με τον εαυτό τους $d_{x}$ καθώς και το διάνυσμα της τιμής πυρήνα όλων των στοιχείων του \texttt{\en{transform}} με τον εαυτό τους $d_{y}$.
Προκειμένου να προκύψει ο κανονικοποημένος πίνακας διαιρεί στοιχείο προς στοιχείο της $Μ \times N$ μήτρας πυρήνα με την τετραγωνική ρίζα κάθε στοιχείου του εσωτερικού γινομένου $d_{y} \times d_{x}$.


\section{\en{Packaging}}
Έκτος από την ίδια την σχεδίαση (\en{design}) και την ανάπτυξη (\en{development}) της, η ολοκλήρωση μίας σύγχρονης βιβλιοθήκης προγραμματισμού απαιτεί την \textit{συσκευασία} της (\en{packaging}).
Αν μία βιβλιοθήκη μπορεί να παρομοιαστεί με μία μηχανισμό, σε επίπεδο ανάπτυξης ένας προγραμματιστής πρέπει να μπορεί να αναγνωρίσει τα δομικά της μέρη, να μπορεί να καταλάβει από τι αποτελούνται, πως κατασκευάζονται και τον τρόπο με τον οποίο συναρμολογούνται, καθώς και να ανιχνεύσει τις αλλαγές τις στο παρελθόν και να γνωρίζει τον παρούσα μορφή της για να δύναται να την διορθώσει ή να την επεκτείνει.
Σε επίπεδο χρήσης, η γνώση της έκδοσης της και η γενική επαλήθευση λειτουργίας της, η ευκολία εγκατάστασης της, η δυνατότητα ελέγχου λειτουργίας χωρίς την γνώση χρήσης της, καθώς και η διάθεση ενός εγχειριδίου που περιέχει πληροφορίες σχετικές με την εγκατάσταση, την χρήση και την κατασκευή της είναι εξίσου απαραίτητα.
Παρόλο που συχνά στο εύρος των ατόμων που απευθύνονται αυτές οι βιβλιοθήκες οι δύο αυτοί ρόλοι προγραμματιστή και χρήστη είναι ζήτημα "εστίασης της προσοχής", είναι χρήσιμο να συντηρούνται ως πόλοι ανάπτυξης του λογισμικού.
\subsection{Ανάπτυξη κώδικα}
Ξεκινώντας από την ανάπτυξη κώδικα σημαντικό είναι να ξεκινήσουμε με τους βασικούς κανόνες συγγραφής του.
\subsubsection{Το πρότυπο \en{PEP-8}}
Προκειμένου ο κώδικας να είναι ευανάγνωστος, η ανάπτυξη κάθε πακέτου προγραμματισμού \en{python} καλείται να ακολουθεί συγκεκριμένους αισθητικούς κανόνες τόσο στο επίπεδο της σύνταξης όσο και της σημασιολογίας.
Το πρότυπο \en{PEP-8} είναι το παρόν πρότυπο σύνταξης για την γλώσσα προγραμματισμού \en{Python}.
Περιέχει κανόνες όπως το μέγιστο δυνατό μήκος μίας γραμμής κώδικα και την στοίχηση των ορισμάτων κατά την κλήση ή τον ορισμό μία συνάρτησης που επεκτείνονται πέραν της μίας γραμμής, μέχρι κανόνες για τον τρόπο ελέγχου ενός τύπου, τον τρόπο χειρισμού εξαιρέσεων (\en{exception handling}) και την χρήση συναρτήσεων αντί για συναρτησιακών (\en{lamda's}) \cite{PEP8}.
Το πρότυπο αυτό μπορεί να παραμετροποιείται από τον εκάστοτε προγραμματιστή, αλλά εξασφαλίζει μία συνοχή στον τρόπο με τον οποίο τελικά συντάσσει κώδικα.
Για τον αυτόματο έλεγχο έχει αναπτυχθεί ένα αντίστοιχο πακέτο γνωστό ως \href{https://pypi.org/project/flake8/}{\en{flake8}}.
\subsubsection{\en{PyPI}}
Κάθε πακέτο \en{python} απαιτεί να μπορεί να εγκατασταθεί οικουμενικά σε όλο το σύνολο των μηχανημάτων για τα οποία προορίζεται.
Κάτι τέτοιο επιλύεται μέσω της ίδιας της \en{python} (βλ. βιβλιοθήκη \href{https://pypi.org/project/setuptools/}{\en{setuptools}}) και απαιτεί από τον προγραμματιστή μονάχα ένα στοιχειώδη τρόπο οργάνωσης της βιβλιοθήκης καθώς και την συγγραφή ενός αρχείου εγκατάστασης \en{setup.py}.
Διαθέτοντας κάτι τέτοιο η βιβλιοθήκη μπορεί να τοποθετηθεί στο ηλεκτρονικό αποθετήριο βιβλιοθηκών της \en{Python}, γνωστό ως \en{PyPI: \textbf{Py}thon \textbf{P}ackage \textbf{I}ndex} μέσω του οποίου μπορεί να εγκατασταθεί από το κύριο εργαλείο εγκατάστασης βιβλιοθηκών της, γνωστό ως \href{https://pypi.org/project/pip/}{\en{pip}}.
Η \en{python} ως γλώσσα με διερμηνέα δεν διαθέτει την έννοια των εκτελέσιμων όπως αυτή υπάρχει από την \en{C} (\en{binaries}) ή την \en{Java} (\en{bytecode}), ταυτίζοντας το πακέτο εκτέλεσης με τον ίδιο τον κώδικα, μέσω των λεγόμενων \en{\textit{eggs}}.
Για να καλυφθεί αυτή η ανάγκη τα λεγόμενα \en{wheels} εισήχθησαν από την κοινότητα που αναπτύσσει την γλώσσα \en{python}.
Κάθε σύγχρονη βιβλιοθήκη επιστημονικού υπολογισμού (\en{scientific-computing}) καλείται να μπορεί συνταιριάξει, το ευχάριστο και μή-περιοριστικό προγραμματιστικός της περιβάλλον, ενώ ταυτόχρονα να μπορεί να συμπεριλάβει τα άγρια και αδέξια πλάσματα των γλωσσών \en{C, C++, Fortran} λόγω της αποδοτικότητας και της αμεσότητας τους.
Τόσο στο επίπεδο του \en{setup.py} και στο επίπεδο των \en{wheels} κάτι τέτοιο δεν αποτελεί μία δυσπρόσιτη πρακτική, ειδικά με την χρήση πακέτων όπως το \href{https://pypi.org/project/Cython/}{\en{Cython}}.
Τέλος σημαντικό για τον έλεγχο κάθε πακέτου είναι η ύπαρξη ενό συνόλου από στοιχειώδη δοκιμαστικά προγράμματα (\en{unit-tests}) προκειμένου πριν την δημοσίευση του κώδικα αλλά και κατά την συντήρηση και επέκταση του να επαληθεύεται η σωστή λειτουργία του.
Πακέτα όπως το \href{https://pypi.org/project/nose/}{\en{nose}} έχουν αναπτυχθεί, προκειμένου η εκτέλεση και η καταγραφή των προβλημάτων που προκύπτουν από αυτά να παρουσιάζεται συνοπτικά, ενώ ενσωματώνουν άλλα όπως το \href{https://pypi.org/project/coverage/}{\en{coverage}} που είναι υπεύθυνο για να παρουσίαζει στατιστικά στοιχεία σχετικά με τον βαθμό στον οποίο τα δοκιμαστικά προγράμματα δοκιμάζουν τον πλήρη κώδικα της βιβλιοθήκης.

\subsection{Δημοσίευση κώδικα}
Όπως προαναφέρθηκε για την δημοσίευση του κώδικας της παρούσας βιβλιοθήκης χρησιμοποιήθηκε το ηλεκτρονικό αποθετήριο \href{https://github.com/ysig/GraKeL}{\en{GitHub}}, παράλληλα με το γεγονός ότι οι εκδόσεις του καταγράφονται μέσω του συστήματος \en{git}.
Απαραίτητα όμως για την δημοσίευση του παρόντος λογισμικού επιστημονικού υπολογισμού \en{python} είναι η ύπαρξη \en{Documentation}, η συνεχή του ενσωμάτωση (\en{Continuous Integration}) καθώς και η άδεια του.
\subsubsection{\en{Documentation}}
Ίσως το πιο σημαντικό βήμα τόσο όσον αφορά τον χρήστη, αλλά και τόσο όσον αφορά τον προγραμματιστή που αναπτύσσει την βιβλιοθήκη, είναι η συγγραφή ενός εγχειριδίου γνωστό με τον όρο \textit{\en{documentation}}.
Από την ίδια την αναλυτική καταγραφή των κλάσεων, την όμορφη παρουσίαση του κώδικα και τις οδηγίες εγκατάστασης, ένα εγχειρίδιο μπορεί να αποτελείται από πολλά περισσότερα μέρη όπως εισαγωγικό κείμενο για την χρήση της βιβλιοθήκης, θεωρητική ανάλυση των απαραίτητων μεθόδων της, πληροφορίες σχετικά με την επέκταση της, και πιο ενδιαφέροντα παραδείγματα χρήσης της.
Η πραγμάτωση όλων των παραπάνω αυτοματοποιείται όσον αφορά την παρουσίαση των κλάσεων και του κώδικα (μέσω κατάλληλης σύνταξης στο επίπεδο των σχολίων) και διευκολύνεται όσον αφορά τα υπόλοιπα, παράγοντας ένα ευχάριστο αισθητικό αποτέλεσμα μέσω του πακέτου \href{https://pypi.org/project/Sphinx/}{\en{Sphinx}}.
\subsubsection{Συνεχής Ενσωμάτωση}
Κάθε νέα έκδοση ενός λογισμικού η οποία προστίθεται στο ηλεκτρονικό αποθετήριο \texttt{\en{GitHub}} πρέπει να συνδέεται με μία εγγύηση ότι αυτή η έκδοση είναι λειτουργική.
Κάτι τέτοιο αποτελεί μία καθιερωμένη πρακτική τα τελευταία χρόνια, μέσω των πλατφορμών συνεχούς ενσωμάτωσης (\en{continuous integration}) οι οποίες επιτρέπουν την ολιγόχρονη αρχικοποίηση ενός λειτουργικού συστήματος και τον προγραμματισμό μία σειράς βημάτων μέσω της οποίας η κατάλληλη παραμετροποίηση του συστήματος, η εγκατάσταση και η δοκιμή της βιβλιοθήκης μπορούν να ελέγχονται αυτόματα αν έρχονται εις πέρας, κάθε φορά που μία νέα έκδοση προτίθεται στο ηλεκτρονικό αποθετήριο.
Συγκεκριμένα ο έλεγχος της βιβλιοθήκης \en{GraKeL} γίνεται σε λειτουργικά συστήμα \en{Linux} και \en{OSX} μέσω της πλατφόρμας συνεχούς ενσωμάτωσης \href{https://travis-ci.org/ysig/GraKeL}{\en{Travis}} και σε λειτουργικό σύστημα \en{Windows} μέσω της πλατφόρμας \href{https://ci.appveyor.com/project/ysig/grakel}{\en{Appveyor}}.
Μιάς και αυτά τα περιβάλλοντα είναι στοιχειώδη (\en{minimal}) και η βιβλιοθήκη κάτι αφηρημένο σε σχέση με το ίδιο το λειτουργικό σύστημα η εγγύηση λειτουργίας τους σε όλες τις υποστηριζόμενες εκδόσεις \en{Python} είναι συνήθως ανεξάρτητη από την έκδοση του λογισμικού (παρόλο που δίνεται η δυνατότητα ορισμού του).
Επιπλέον οι πλατφόρμες αυτές χρησιμοποιήθηκαν για την ανάπτυξη και απόθεση (\en{build and deploy}) \en{wheels} για ένα εύρος συστημάτων και όλες τις υποστηριζόμενες εκδόσεις \en{python} στο \en{PyPi}, μέσω της βιβλιοθήκης \href{}{\en{cibuildwheel}}.
Μία τρίτη πλατφόρμα χρησιμοποιήθηκε για την ανάπτυξη και απόθεση του \en{documenation}, συγκεκριμένα η \href{https://circleci.com/gh/ysig/GraKeL/tree/develop}{\en{Circle-CI}}.
Η λειτουργικότητα τις βιβλιοθήκης όπως επισημαίνεται από τα παραπάνω καθώς και το ποσοστό του \en{coverage} όπως αυτό αποτίθεται στην πλατφόρμα \href{}{\en{coveralls}} μέσω του \en{travis}, φαίνονται με την μορφή \en{badges} στην κύρια σελίδα στο αποθετήριο του \href{}{GraKeL}.

\subsubsection{Άδεια}
Είναι καθιερωμένο για κάθε επίσημα δημοσιοποιημένο λογισμικό να κατέχει μία άδεια χρήσης.
Για την δημοσίευση του \en{GraKeL} επιλέχθηκε η ίδια άδεια χρήσης με αυτή του \href{https://en.wikipedia.org/wiki/Scikit-learn}{\en{scikit-learn}}, συγκεκριμένα την \href{https://en.wikipedia.org/wiki/BSD_licenses#3-clause_license_(%22BSD_License_2.0%22,_%22Revised_BSD_License%22,_%22New_BSD_License%22,_or_%22Modified_BSD_License%22)}{άδεια \en{BSD} 3 ρητρών}.
Η άδεια αυτή είναι μία άδεια αποδεκτή από την κοινότητα ελευθέρου λογισμικού (\en{FSF-approved}), με τρία στοιχειώδη απαιτούμενα.
Συγκεκριμένα, την επανατοποθέτηση αυτής της άδειας σε αναδιανομές του λογισμικού τόσο αν αυτές είναι σε μορφή κώδικα ή εκτελέσιμου, καθώς και την διαφύλαξη των μελών του προσώπου δικαίου που φέρει τα πνευματικά δικαιώματα, από την χρήση των ονομάτων τους για την πρόκριση ή την προώθηση παραγώγων αυτού του λογισμικού, χωρίς να έχει προηγηθεί η γραπτή τους άδεια.

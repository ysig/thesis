\chapter{Ανάπτυξη του \en{GraKeL}}
\label{chap3}
Η σχεδίαση μίας μοντέρνας βιβλιοθήκης προγραμματισμού δεν είναι μία απλή υπόθεση.
Ο προγραμματιστής καλείται να συνδιάσει ``κοινωνικές'' ιδιότητες της βιβλιοθήκης, όπως η ευχρηστία και η υψηλου επιπέδου οργάνωση, με ιδιότητες ``υλικού'' που προκύπτουν από το στόχο της υπολογιστικής αποτελεσματικότητας.
Σε αυτό το κεφάλαιο θα ασχοληθούμε με την βιβλιοθήκη από την σκοπιά της ανάπτυξης λογισμικού.
Πρώτα θα περιγράψουμε τον βασικό σκελετό οργάνωσης της βιβλιοθήκης, το μοντέλο προγραμματισμού την οργάνωση και το 
Έπειτα θα ασχοληθούμε με συγκεκριμένες υπομονάδες του ίδιου του πακέτου προκειμένου να περιγράψουμε των τρόπο με τον οποίο λειτουργούν καθώς και τις δυνατότητες τους.
Τέλος θα δωθούν συμπληρωματικές πληροφορίες σχετικά με το πως μία σύγχρονη βιβλιοθήκη προγραμματισμού συσκευάζεται \en{packaging}, διανέμεται και δοκιμάζεται.
\section{Σχεδιαστικές Αποφάσεις}
Το \en{GraKeL} επιλέχθηκε να αναπτυχθεί σε γλώσσα προγραμματισμού \en{Python}.
Η γλώσσα αυτή έχει αποδείξει την αξία της τόσο στην έρευνα όσο και στις εφαρμογές \cite{PythonHype}.
Διαθέτει εκτέλεση με διερμηνέα (\en{interpreter}), που διευκολύνει τον προγραμματιστή να αναπτύσει εφαρμογές πολύ γρήγορα, καθώς λόγω του οκνηρού συστήματος τύπων που διαθέτει, τα σημασιολογικά λάθη προκύπτουν μόνο την στιγμή που θα αποτελεσούν πρόβλημα.
Κάτι τέτοιο κάνει την διαδικασία της διόρθωσης του προγράμματος (\en{debugging}) συγχρονική της ίδια της εκτέλεσης.
Ταυτόχρονα υποστηρίζει το μοντέλο του αντικειμενοστραφούς προγραμματισμού που επιτρέπει την συγχρονη σχεδίαση μία βιβλιοθήκης.
Στο μοντέλο αυτό η στοιχειώδης δομή δεδομένων καλείται αντικείμενο και αποτελεί πραγματικό στιγμιότυπο στη μνήμη ενός σύνθετου, και πιθανώς οριζόμενου από τον χρήστη, τύπου δεδομένων ονόματι κλάση.
Κάθε κλάση απότελείται από ιδιότητες εσωτερικές μεταβλητές (\en{attributes}) και μεθόδους.
Π.χ. μία κλάση μπορεί να είναι ο γράφος που διαθέτει ιδιότητες όπως το σύνολο των κόμβων, το σύνολο των ακμών και τις επισημειώσεις και μεθόδους όπως ο υπολογισμός της πυκνότητας του, του πίνακα κοντινότερων μονοπατιών ή ακόμα και πράξεις μεταξύ αντικειμένων αυτής της κλάσης γράφων όπως το γινόμενο.
Το χαρακτηριστικό αυτό μίας γλώσσας δίνει την ευελιξία στην/ον προγραμματίστρια/τιστή τόσο να επεκτείνει τρομερά αποτελεσματικά τις υπάρχουσες δομές δεδομένων που υπάρχουν από την δημιουργία της, όσο και να εκμεταλλεύεται την ανεξάρτητη χρονική οντότητα κάθε αντικειμένου, ενσωματόντας το αυτόματα με τις παραμετροποιημένες εκδόσεις ενός συνόλο συναρτήσεων που το αφορούν.
Ακόμα οι συντακτικοί κανόνες της γλώσσας είναι διαμορφωμένοι με τέτοιο τρόπο που η στοίχιση κώδικα χρησιμοποιείται προκειμένου να μειωθεί την χρήση συντακτικών συμβόλων, κανόντας πολύ ευκολότερη την ανάγνωση του κώδικα και κατ'επέκταση την περαιτέρω ανάπτυξη ή ενσωμάτωση υπάρχοντος κώδικα σε εφαρμογές.

Ο σημαντικότερος βέβαια λόγος για τον οποίο η γλώσσα προγραμματισμού \en{Python} έχει επικρατήσει, που είναι τόσο αποτέλεσμα όσο και η αιτία του σχεδιασμού της είναι το μεγάλο \textit{οικοσύστημα} βιβλιοθηκών, εργαλείων και πλαισίων λογισμικού τα οποία έχουν αναπτυχθεί σε αυτήν τα τελευταία χρόνια ταυτόχρονα με την επικράτηση της ελεύθερης διάθεσης τους κι τροποποίησης τους μέσω των αδειών ανοιχτού λογισμικού.
Για να απλοποιήσουν αυτή τη διαδικασία οι σχεδιαστές της \en{python} δημιούργησαν ένα \en{package manager} γνωστό ως \en{pip} υπεύθυνο για την εγκατάσταση βιβλιοθηκών καθώς και μία πλατφόρμα γνωστή ως \en{PyPi} στην οποία οποιοσδήποτε μπορεί να ανεβάσει πακέτα προς εγκατάσταση.
Πολύ σημαντικός παράγοντας στην διάδοση, τον διαμειρασμό και την επεξεργασία του ανοιχτού κώδικα αποτέλεσε η ύπαρξη ηλεκτρονικών αποθετηρίων όπως το \en{GitHub}.
Χρησιμοποιώντας ένα λογισμικό που είχε αρχικά αναπτυχθεί για τον συνεπή έλεγχο των εκδόσεων (\en{version control}) στην ανάπτυξη του πυρήνα του \en{Linux}, γνωστό ως \en{git}, ηλεκτρονικά αποθετήρια αυτής της μορφής καθιστούν ιδιαίτερα εύκολη την προβολή, χρήση και την συνεισφορά ή επέκταση του κώδικα οποιουδήποτε χρήστη τους από οποιονδήποτε άλλο.
\subsection{Το πρότυπο του \en{scikit-learn}}
Μία πολύ γνωστή βιβλιοθήκη μηχανικής μάθησης στην \en{Python} είναι γνωστή ως \en{scikit-learn}. Εκτός από τις πολύ γρήγορες υλοποιήσεις ενός μεγάλου πλήθους αλγορίθμων σε ένα μεγάλο εύρος τεχνικών στο χώρο της μηχανικής μάθησης η βιβλιοθήκη αυτή συνδιάζει τρομερή ευχρηστία ταυτόχρονα με αναλητικά εγχειρίδια για όλους τους διαφορετικούς υποψήφιους χρήστες της (οι οποίοι είναι της τάξης των εκατομμυρίων) \cite{scikit}.
Προκειμένου διάφοροι χρήστες της να μπορούν να προτείνουν δυνατές επεκτάσεις της καθώς και για να καθιερώσει ένα πρότυπο κλάσεων μηχανικής μάθησης για τον αντικειμενοστραφή προγραμματισμό, ένα πλαίσιο λογισμικού \en{sklearn-template} δημιουργήθηκε στο \en{GitHub}.
Λόγω των παραπάνω και με βάση το γεγονός ότι δεν υπήρχε υποστήριξη για το είδος των τεχνικών πυρήνα, συγκεκριμένα των πυρήνων γράφων το παραπάνω σχεδιαστικό πρότυπο επιλέχθηκε για την ανάπτυξη του \en{GraKeL}.
Σαν σχέση υιοθέτησης δύο θεμελιωδών κλάσεων του scikit-learn συγκεκριμένα της κλάσης \en{\texttt{sklearn.base.\textbf{BaseEstimator}}} και της κλάσης \en{\texttt{sklearn.base.\textbf{TransformerMixin}}} σχεδιάστηκε η βασική κλάση του \en{grakel}, γνωστή ως \en{\texttt{grakel.\textbf{Kernel}}}.
Κάθε υλοποίηση ενός πυρήνα γράφων να αποτελεί μία κλάση που υιοθετεί την κλάση \en{\texttt{Kernel}}. 
Η κλάση αυτή αποτελεί κάτι ενδιάμεσο μίας διεπαφής (δηλ. ενός συνόλου δηλώσεων ονομάτων μεθόδων και χαρακτηριστικών με κενό περιεχόμενο) και μία κανονικής κλάσης.
Συγκεκριμένα περιέχει κατάλληλες μεθόδους που αν υλοποιηθούν από τον προγραμματιστή η ανάπτυξη του πυρήνα συντομεύεται.
Tαυτόχρονα κάθε αντικείμενο που είναι ένας έγκυρος πυρήνας μεταξύ γράφων πρέπει να υλοποιεί κάποιες βασικές μεθόδους και συνεπώς να υλοποιεί μία διεπαφή.
Όλοι οι πυρήνες τοποθετήθηκαν σε ένα υπο-πακέτο του \en{grakel} υπό την διέυθυνση \en{\texttt{grakel.kernels}}.
Κάθε αντικείμενο που υλοποιεί το πρότυπο \en{\texttt{TransformerMixin}} υλοποιεί τρείς μεθόδους:
  \begin{itemize}
    \item \texttt{\en{fit}}: Προσαρμογή του μοντέλου σε ένα σύνολο δεδομένων γνωστό ως \textit{σύνολο εκπαίδευσης} (εξαγωγή χαρακτηριστικών, παραμετροποίηση κ.α.)
    \item \texttt{\en{transform}}: Υπολογισμός των τιμών του μοντέλου σε ένα \textit{πειραματικό σύνολο}, βάση του αποτελέσματος της παραμετροποίησης στο σύνολο εκπαίδευσης
    \item \texttt{\en{fit\_transform}}: Προσαρμογή και υπολογισμός του μοντέλου στο \textit{σύνολο εκπαίδευσης} (κάποιες φορές μπορεί να προσφέρει μία γρηγορότερη υλοποίηση από την ακολουθία \texttt{\en{fit}} - \texttt{\en{transform}} στα ίδια δεδομένα)
\end{itemize}
Ταυτόχρονα το πρότυπο \en{\texttt{BaseEstimator}} αποτελείται από δύο μεθόδους \texttt{\en{set\_params}}, \texttt{\en{get\_params}}, οι οποίες αν υλοποιηθούν σωστά καθιστούν δυνατή την εξαγωγή παραμέτρων αρχικοποίησης \en{initialization parameters} καθώς και την εξωτερική επανάθεση αυτών των παραμέτρων σε ένα αρχικοποιημένο αντικείμενο μιας κλάσης προκειμένου να ξαναχρησιμοποιηθεί αρχικοποιημένο με διαφορετικές παραμετροποιήσεις, χωρίς την χρήση της ίδιας της κλάσης.
Κάθε κλάση πρέπει περαιτέρω να διατυπώνει όλες τις παραμέτρους ορισμού της, ρητά.
Τα παραπάνω είναι σημαντικά προκειμένου ένας \en{Transformer} που σχεδιάζει ο προγραμματιστής να μπορεί να εισαχθεί στο λεγόμενο \en{scikit-learn \texttt{Pipeline}}.
Ως τέτοιο μπορεί να εισαχθεί, να αντικατασταθεί και να προσαρμοστεί εύκολα και αφηρημένα σε μία δομή υψηλού επιπέδου βημάτων επεξεργασίας - ταξινόμησης - αξιολόγησης μίας αρχικής εισόδου δεδομένων, σχεδιάζοντας σχεδόν σε διανοητικό επίπεδο μία εφαρμογή ή ένα πείραμα μηχανικής μάθησης.
Για να τηρούνται συνεπώς τα παραπάνω σημαντική ήταν η σχεδίαση της κλάσης πυρήνα.
\subsection{Σχεδίαση της κλάσης \texttt{\en{Kernel}}}
Όπως είδαμε στο κεφάλαιο \ref{chap2}, ένας πυρήνας μεταξύ γράφων εμφανίζεται συνήθως στη βιβλιογραφία σαν μία συνάρτηση: $k \; : \; \mathcal{G} \times \mathcal{G} \rightarrow \mathbb{R}$ για την οποία υπάρχει μία απεικόνηση:$$\phi \; :\; \mathcal{G} \rightarrow \mathbb{H}, \text{για έναν χώρο \en{Hilbert} } \mathbb{H}$$ όπου κάθε τιμή πυρήνα μπορεί να υπολογιστεί ως $k(G_{i}, G_{j}) = \langle G_{i}, G_{j} \rangle$ όπου $\langle \;.\; ,\; .\;\rangle$ αναπαριστά ένα εσωτερικό γινόμενο σε αυτόν τον χώρο. Η μήτρα $[\mathcal{K}]_{ij} = k(G_{i}, G_{j})$ που προκύπτει από όλα τα ζευγάρια γράφων μίας συλλογής, ονομάζεται μήτρα πυρήνα (βλ. \ref{def:kernel_matrix}). Οποιαδήποτε μήτρα που προκύπτει από ένα μέτρο ομοιότητας είναι μήτρα πυρήνα αν για κάθε συλλογή εισόδων είναι θετικά ημιορισμένη (βλ. \ref{def:psd_km}), δηλαδή αν $\forall \mathcal{K}\; \lambda_{min}(\mathcal{K}) \ge 0$, όπου $\lambda_{min}(\mathcal{K})$ η μικρότερη ιδιοτιμή του πίνακα $K$.
%Note
%The ones implemented inside this package all have a \textbf{Polynomial} time complexity.
Μελετώντας υπάρχουσες υλοποιήσεις πυρήνων στη βιβλιογραφία αυτό που διαπιστώσαμε ήταν ότι αν αντί να σχεδιάζαμε την κλάση πυρήνα ώστε να υπολογίζεται μεταξύ ζευγαριών, την σχεδιάζαμε για μία συλλογή γράφων $[G]_{i=1}^{N}$ θα είχαμε σημαντικά υπολογιστικά πλεονεκτήματα.

Ο τρόπος με τον οποίο η κλάση \en{\texttt{Kernel}} σχεδιάστηκε πάνω στο πρότυπο του \en{\texttt{Transformer}} είναι ο ακόλουθος:
\begin{itemize}
    \item \texttt{\en{fit}}: Εξαγωγή χαρακτηρηστικών για ένα σύνολο γράφων εκπαίδευσης
    \item \texttt{\en{transform}}: Υπολογισμός του πίνακα πυρήνα μεταξύ ενός συνόλου γράφων πειραματισμού και των αρχικών, είτε εξάγωντας και συγκρίνοντας όμοια χαρακτηρηστικά με αυτά του \texttt{\en{fit}} είτε υπολογίζοντας τιμές βάση των χαρακτηρηστικών του \texttt{\en{fit}} είτε τέλος επεκτείνοντας τα και υπολογίζοντας μία γενικής μετρικής (χωρίς βέβαια την αποθήκευση της επέκτασης).
\end{itemize}
Τέλος για \texttt{\en{fit\_transform}} έχουμε ένα συνδιασμό των παραπάνω πράγμα που συνήθως αποτελεί την μόνη λειτουργία εκτελούν όλοι οι υπάρχοντες υλοποιημένοι πυρήνες της βιβλιογραφίας από τους ίδιους τους σχεδιαστές τους.

Για να γίνει πιο σαφές το παραπάνω με βάση την μήτρα πυρήνα, δεδομένου δύο συλλογών γράφων (εκπαίδευσης/πειράματος): $G^{n}, G^{m}$, θεωρούμε την πλήρη μήτρα πυρήνα $\mathcal{K}$ ως:
\begin{equation}
\mathcal{K} =
\left[
\begin{array}{c||c}
\mathcal{K}^{n\times n} & \mathcal{K}^{n\times m} \\
\hline
\hline
\mathcal{K}^{m\times n} & \mathcal{K}^{m\times m}
\end{array}
\right]
\label{eq:kernel_matrix}
\end{equation}

Τότε κάθε πυρήνας κλάση που υλοποιεί την κλάση \en{\texttt{Kernel}}, θα πρέπει να έχει την ακόλουθη συμπεριφορά:
\begin{itemize}
\item $\mathcal{K}^{n\times n}=\texttt{\en{<KernelName>.fit\_transform}}(\mathcal{G}^{n})$
\item $\mathcal{K}^{m\times n}=\texttt{\en{<KernelName>.fit}}(\mathcal{G}^{\text{n}}).\texttt{transform}(\mathcal{G}^{\text{m}})$
\item $\mathcal{K}=\texttt{\en{<KernelName>.fit\_transform}}([\mathcal{G}^{n}\; \mathcal{G}^{m}])$
\end{itemize}
Σε ένα πρόβλημα ταξινόμησης γράφων (βλ. \ref{subsection:graph_classification}), αυτό που χρειάζεται να υπολογίσουμε είναι οι πυρήνες $\mathcal{K}^{n\times n}$ και $\mathcal{K}^{m\times n}$. Μία τέτοια συμπεριφορά προέκυψε και ως αναγκαιότητα για την ένταξη κάθε \texttt{\en{Kernel}} στο \en{\texttt{Pipeline}}.

Εν συνεχεία κάθε πυρήνας σχεδιάστηκε με την ακόλουθη στοιχειώδη \textit{παραμετροποίηση}:
\begin{itemize}
\item \en{\texttt{verbose}} Μία λογική (\en{\texttt{bool}}) παράμετρος για να δίνει την δυνατότητα στον προγραμματιστή να παρέχει πληροφορία σχετικά με την πορεία εκτέλεση του kernel σε περίπτωση επιθυμίας του χρήστη.
\item \en{\texttt{normalize}} Η κανονικοποίηση είναι μία πολύ σημαντική ιδιότητα που πρέπει να ακολουθεί ένας πυρήνας προκειμένου να είναι χρήσιμος σε πειράματα ταξινόμησης. Αυτή η λογική (\en{\texttt{bool}}) παράμετρος αναγκάζει τον προγραμματιστή να μπορεί να εξασφαλίζει στον χρήστη της βιβλιοθηκής ότι σε περίπτωση που το επιθυμεί η ο πίνακας πυρήνας θα είναι κανονικοποιημένος τόσο στα αποτελέσματα του \en{\texttt{fit\_transform}} όσο και του \en{\texttt{transform}} Η κανονικοποίηση είναι μία πολύ απλή πράξη διαίρεσης δεδομένων των τιμών της διαγωνίου της μήτρας πυρήνα ως εξής:
    \begin{equation}
        [\mathcal{\hat{K}}]_{ij} = \frac{[\mathcal{K}]_{ij}}{\sqrt[]{[\mathcal{K}]_{ii}*[\mathcal{K}]_{jj}}}
    \end{equation}
\item \en{\texttt{n\_jobs}} Μία ακέραια \en{\texttt{int}} παράμετρος που προσδιορίζει το πλήθος των παράλληλων εργασιών στις οποίες επιθυμεί ο χρήστης να διαμοιραστούν οι παραλληλοποιήσιμες εργασίες του συγκεκριμένου πυρήνα, αν υπάρχουν.
\end{itemize}

Όσον αφορά την υλοποίηση των λίγων ως τώρα \en{framework} δεν ορίστηκε μία ξεχωριστή κλάση.
Παρόλαυτα η σχεδίαση τους είχε ως κοινό χαρακτηριστικό την προσθήκη μίας παραμέτρου αρχικοποίησης (στο όνομα \en{\texttt{base\_kernel}}) η οποία μπορούσε να είναι είτε μία κλάση τύπου \en{\texttt{Kernel}} είτε μία τούπλα (\en{\texttt{tuple}}) δύο στοιχείων με πρώτο μία κλάση τύπου \en{\texttt{Kernel}} και δεύτερο ένα σύνολο ορισμάτων.
Για να είναι δυνατή η κανονικοποίηση του αποτελέσματος των \en{framework} μία νέα μέθοδος χρειάστηκε να προστεθεί σχεδιαστικά σε κάθε αντικείμενο της κλάσης \en{\texttt{Kernel}}: η μέθοδος \en{\texttt{diagonal}}.
Η μέθοδος δεν δέχεται ορίσματα και πρέπει να έχει πάντοτε την ακόλουθη συμπεριφορά. Αν ένας πυρήνας έχει γίνει \en{\texttt{fit}} αλλά όχι \en{\texttt{transform}}, τότε επιστρέφει την διαγώνιο $[\mathcal{K}^{n\times n}]_{ii}$ (πρβλ. \ref{eq:kernel_matrix}).
Αν αντίθετα ένας πυρήνας έχει γίνει \en{\texttt{fit}} και \en{\texttt{transform}} τότε επιστρέφει την διαγώνιο του $[\mathcal{K}^{n\times n}]_{ii}$ και την διαγώνιο του $[\mathcal{K}^{m\times m}]_{jj}$ από το τελευταίο \en{\texttt{transform}}.
Σημαντικό εδώ είναι να σημειώσουμε ότι τα στοιχεία της διαγωνίου $[\mathcal{K}^{m\times m}]_{jj}$ δεν υπολογίζονται κατά το \en{\texttt{transform}} (δλδ. οι τιμές πυρήνα όλων των στοιχείων με τον εαυτό τους), αν ο χρήστης δεν έχει επιλέξει κανονικοποίηση.

Με σκοπό την ύπαρξη μίας κύριας κλάσης - αφηρημένης διεπαφής στην οποία ο χρήστης να απευθύνεται προκειμένου να αρχικοποιήσει έναν πυρήνα, να δημιουργήσει εύκολα ιεραρχίες \en{\texttt{framework/base-kernel}} και να μπορεί να εκτελεί γενικότερες πρόσθετες εξωτερικές λειτουργίες που χρησιμοποιούν τον πίνακα πυρήνα (π.χ. να υπολογίσει προσεγγίσεις του, όπως η προσέγγιση \en{Nystr{\"o}m}), ένα αντικείμενο σχεδιάστηκε στο σχεδιαστικό πρότυπο του \en{decorator} ονόματι \texttt{\en{GraphKernel}}.

\subsection{Γενική Μορφή Εισόδου}
Η ανάγκη σχεδιαστικής ενοποίησης όλων των πυρήνων οδήγησε και στην ανάγκη δημιουργία ενός προτύπου αναπαράστασης της εισόδου των μεθόδους \en{\texttt{fit}, \texttt{fit\_transform }} και \en{\texttt{transform}} καθενός αντικειμένου τύπου \en{\texttt{Kernel}}.
Ακολουθώντας το πρότυπο του \en{scikit-learn} για άλλους \en{\texttt{Transformer}} όπως ο \en{tf-idf}, η είσοδος θεωρήθηκε σαν ένας \textit{\en{graph vectorizer}} ή αλλιώς ένα \en{\texttt{Iterable}} από γράφους (πρβλ. \ref{fig:graph}).
Κάθε γράφος μπορεί να αναπαρασταθεί από ένα \en{\texttt{Iterable}} τουλάχιστον ενός και το πολύ τριών στοιχείων.

Πρώτο στοιχείο κάθε γράφου πρέπει να είναι ένα αντικείμενο που αναπαριστά το γράφο ως δομή.
Οι υπάρχουσες αναπαραστάσεις γράφων στην βιβλιογραφία χωρίζονται σε αυτές που βασίζονται στις ακμές του γράφου ($1$) και σε αυτές που βασίζονται στους κόμβους ($2$).
Οι πρώτες αναπαραστάσεις μπορούν να είναι από μία λίστα κόμβων μέχρι ένα λεξικό, ενώ οι δεύτερες περιγραφονται κυρίως με έναν πίνακα γειτνίασης.
Ως δεύτερο στοιχείο μπορούμε να έχουμε ένα λεξικό που αναπαριστά τις επισημειώσεις των κόμβων του γράφου. Οι επισημειώσεις μπορούν να είναι είτε βαθμωτές, σύμβολα είτε διανύσματα πραγματικών τιμών (χαρακτηρηστικά, πρβλ \ref{def:labeled_graphs}).
Τρίτο και τελευταία στοιχείο είναι ένα λεξικό μεταξύ ζευγαριών κόμβων για όλες τις υπάρχουσες ακμές και είτε βαθμωτών, συμβολικών επισημειώσεων είτε διανύσματων πραγματικών τιμών.
Τα δύο στοιχεία μπορούν να παραληφθούν ή να αντικατασταθούν από κενά ορίσματα (τύπου \en{\texttt{None}}) στην περίπτωση που δεν υπάρχουν.

Η αναπαράσταση των γράφων ήταν πολύ σημαντική για τους ίδιους τους πυρήνες.
Πολλοί πυρήνες όπως ο \textit{πυρήνας τυχαίων περιπάτων} χρησιμοποιούν άμεσα τον πίνακα γειτνίασης, πυρήνες όπως ο \textit{πυρήνας κοντινότερων μονοπατιών} χρειάζονται μόνο τον πίνακα κοντινότερων μονοπατιών (που υπολογίζεται ταχύτερα αν έχουμε αναπαράσταση ακμών, λόγω του αλγορίθμου Dijkstra) ενώ άλλοι πυρήνες όπως για παράδειγμα ο \en{ODD-STh} χρησιμοποιούν δευτερεύουσα πληροφορία του γράφου που αν κωδικοποιηθεί σωστά εξάγεται γρηγορότερα σε μία από τις δύο αναπαραστάσεις.
Συνεπώς χρειάζονταν ένας τρόπος προκειμένου οι γράφοι να μην αναπαριστούν πολύ μνήμη, ενώ ταυτόχρονα να μπορούμε να ελέγχουμε το είδος της εσωτερικής εσωτερική αναπαράστασης ανά περίπτωση, έχοντας ταυτόχρονα την δυναότητα να καθορίσουμε την μορφή του αποτελέσματος συναρτήσεων πάνω στους γράφους, χρήσιμων για τους υπολογισμούς των πυρήνων, χωρίς να χρειάζεται συνεχώς να ασχολούμαστε με την μορφή της πρώτης.
Ως αποτέλεσμα δημιουργήθηκε η κλάση \en{\texttt{grakel.Graph}} η οποία ενοποίησε την είσοδο του χρήστη σε δύο βασικές εσωτερικές αναπαραστάσεις των οποίων την ύπαρξη ή συνύπαρξη καθορίζει ο προγραμματιστής των πυρήνων και από τις οποίες μπορεί να εξάγει χρήσιμη πληροφορία για τους πυρήνες χωρίς να ασχολείται μετέπειτα κατά τον προγραμματισμού του με την μορφή των δεδομένων εισόδου ή της ίδια της εσωτερικής αναπαράστασης.
Παρόλο που μία τέτοια σχεδιαστική προσέγγιση φαίνεται πολύ απλοική προτιμήθηκε σε σχέση με την χρήση μίας υπάρχουσας βιβλιοθήκης όπως η \en{\texttt{networkx}}, μίας και χρειάζεται για την επίλυση ενός στενά καθορισμένου προβλήματος με το λιγότερο δυνατό κόστος.

\begin{figure}[]
    \centering
    \includegraphics[width=\textwidth]{figures/Graph}
    \caption{Σχηματική απεικόνιση του τρόπου αναπαράστασης της εισόδου για της μεθόδους \texttt{\en{fit}}, \texttt{\en{fit\_transform}} και \texttt{\en{transform}} κάθε αντικειμένου τύπου \en{\texttt{Kernel}}}
    \label{fig:graph}
\end{figure}
% datasets

Σημαντικό κομμάτι της ίδιας της ανάπτυξης του λογισμικού είναι η δυνατότητα εκτέλεσης \en{benchmarks}.
Για το λόγο αυτό υπήρχε η ανάγκη παροχής υπηρέσιων εύκολης εισαγωγής γνωστών \en{dataset} που χρησιμοποιούνται στο χώρο των πυρήνων γράφων.
Για να καλύψουμε αυτήν την ανάγκη οδηγηθήκαμε στην ανάπτυξη μίας συνάρτησης εν'ονόματι \en{\texttt{fetch\_dataset}} σε ένα υποπακέτο του \en{\texttt{grakel}} με το όνομα \en{\texttt{datasets}}.
Η συνάρτηση αυτή είναι υπεύθυνη για το κατέβασμα (\en{downloading}), την φόρτωση (\en{loading}) και την τοπική απόθεση (\en{caching}) ενός \en{dataset} από μία τεράστεια συλλογή όπως αυτή συντηρείται και ελέγχεται από την ερευνητική ομάδα για τους πυρήνες γράφων στο πανεπιστήμιο του \en{Dortmund} \cite{KKMMN2016}. Κάθε \en{dataset} αποθηκεύεται σε μία τοπική διεύθυνση, ώστε να μπορεί να χρησιμοποιήθει στο μέλλον χωρίς την ύπαρξη σύνδεσης στο διαδίκτυο.

H συνολική οργάνωση του \en{grakel} όπως αναφέρθηκε, συνοψίζεται παρακάτω:
\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{figures/grakel-schema}
    \caption{Σχηματική απεικόνιση της οργάνωσης του λογισμικού \en{grakel}. Οι ρόμβοι αναπαριστούν υποπακέτα (\en{submodules}) ενώ τα παραλληλόγραμμα κλάσεις.}
    \label{fig:grakel}
\end{figure}
\section{Ανάπτυξη ενός πυρήνα: Η κλάση \en{\texttt{Kernel}}}
Ας δούμε τώρα πιο αναλυτικά την σχεδίαση της κλάσης \en{\texttt{Kernel}} που αποτελεί την κύρια και σημαντικότερη οντότητα αυτής της βιβλιοθήκης.
Από την μελέτη της σχετικής βιβλιογραφίας ο υπολογισμός ενός γράφου πυρήνα μπόρεσε να αποδομηθεί στα εξής δύο αφηρημένα βήματα: ανάγνωση της εισόδου και εξαγωγή χαρακτηρηστικών ($1$) και υπολογισμός πίνακα πυρήνα ($2$).
Έτσι κατά την κλήση του \texttt{\en{fit}} η βασική συνάρτηση η οποία καλείται είναι η \texttt{\en{parse\_input}} σχεδιασμένη για να φέρει εις πέρας το ($1$) και να αποθηκεύσει τα χαρακτηρηστικά σε μία ιδιοτητα της κλάσης.
Παράλληλα προκειμένου η κλάση \en{\texttt{Kernel}} να υιοθετεί σωστά τον \en{\texttt{BaseEstimator}} ήταν αναγκαίο η μέθοδος \en{\texttt{set\_params}} να δουλεύει αποτελεσματικά έπειτα από την αρχικοποίηση ενός αντικειμένου, ενώ ταυτόχρονα στην μέθοδο  \en{\texttt{\_\_init\_\_}} όλες οι παράμετροι εισόδου έπρεπε να αρχχικούν ιδιότητες με το ίδιο όνομα, για να δουλεύει η μέθοδος \en{\texttt{get\_params}}.
Ο έλεγχος μεταβλητών και η αρχικοποίηση δευτερεύοντων χαρακτηρηστικών ανατέθηκε στην συνάρτηση \texttt{\en{initialize\_}} η οποία καλείται στην πρώτη γραμμή της συνάρτησης mεθόδου \texttt{\en{fit}}.
\begin{figure}[]
    \centering
    \includegraphics[width=\textwidth]{figures/KernelStructure.png}
    \caption{Σχηματική απεικόνιση του τρόπου οργάνωσης των μεθόδων της κλάσης \en{\texttt{Kernel}}. Τα νούμερα συμβολίζουν την κλήσης άλλων μεθόδων από την εκάστοτε μέθοδο. Η διακοπτόμενη κλήση αφορά την περίπτωση που κατά την αρχικοποίηση η παράμετρος normalization είναι \en{\texttt{True}}.}
    \label{fig:kernel_structure}
\end{figure}
\section{\en{Packaging}}
%Αδειε, CI, pypi deploy documentation
